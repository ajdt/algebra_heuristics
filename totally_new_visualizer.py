#!/usr/bin/env python

##
# @author   Armando Diaz Tolentino <ajdt@cs.washington.edu> 
#
# @brief    A simple visualizer for the equations generated by ASP code in eqn_generator.lp.
#           This is a reworked version of eqn_viz.py
#
# @warning  requires asp output in json format. As of gringo4 this is possible with
#           clingo --outf=2 <gringo_file.lp>
#       
# @warning  expects output from stdin, pipe clingo output to this program


import pred_parser
import json
import sys
import argparse # for command line args
from collections import defaultdict, namedtuple
import explanation_extractor as explain
from model_manager import ModelManager
import translate_tree_nodes as translator

# operator symbols for eqn string generation
op_symbols      =   {'add' : '+' , 'div' : '/' , 'mul' : '*' , 'neg' : '-'}

# TODO: remove these once factor predicates are changed too!
factor_predicates = ['factor' + n for n in list('1234')]
factor_name_dict = {'factor1':'FACTORA' , 'factor2':'FACTORB', 'factor3':'FACTORX', 'factor4':'FACTORY' }

# list of strategies
all_strategies = ['cancel', 'combine', 'rearrange', 'move', 'expand']
# contains associated methods for parsing a single math problem 
# and its solution (same as a single answer set)
GeneratedStep = namedtuple('GeneratedStep', ['equation_string', 'step_data'])

##
# Parses predicates related to one step of a solution trace
# contains the data members: 
#   var_str     --  what variable an equation should be expressed with
#   node_data   --  dictionary containing all node info parsed
#   strategy_data   --  parsed explanations for the different strategy classes   
class EquationStepParser:
    ##
    # @param[in]    var_str     variable to use when constructing equation (typically it's 'x' or 'y')
    def __init__(self, var_str='x'):
        self.var_str       = var_str
        # contains denom, numer, coeff, degree and other node info from holds predicate
        self.node_data      =   defaultdict(defaultdict)
        # miscellaneous step information that will be recorded/saved
        # TODO: misc_data initialization getting too complex, change it?
        self.misc_data      = {'operands':[], 'action':'', 'factor_data': {}, 'explanation':[], 'time':''}
        self.strategy_data  = defaultdict(list)
        self.optimal_action = ''
        self.optimal_operands = []

    ##
    # @param[in]    new_var     new variable string to use
    def updateVariable(self, new_var):
        self.var_str = new_var

    ##
    # EquationStepParser contains lots of data we don't need after parsing
    # this method returns a GeneratedStep instance that has only what we want to save
    def toGeneratedStep(self):
        # add strategy_data and return generated step instance
        self.misc_data['strategy_data'] = dict(self.strategy_data)
        return GeneratedStep(self.getEqnString(), self.misc_data)
    # save field/value info for a node
    def addHoldsPredicate(self, holds_pred):
        node_id, field, value   = pred_parser.holdsObjectToNodeFieldValue(holds_pred)
        node_data_dict          = self.node_data[node_id]

        # a node has many activechild values, only one for every other field
        if field == 'activechild' and 'activechild' not in node_data_dict.keys():
            node_data_dict[field] = [value]
        elif field == 'activechild':
            node_data_dict[field].append(value)
        else:
            node_data_dict[field] = value

    # add a predicate of the type 'strategyExplanation'
    def addStrategyPredicate(self, pred_obj):
        strategy_pred = pred_obj.args[1]
        strategy_name = strategy_pred.args[0].name
        strategy_desc = explain.convertFromCamelCase(strategy_pred.name).replace('strategy', strategy_name)
        has_heur_instance = len(strategy_pred.args) == 2

        if has_heur_instance:
            heur_obj    = pred_parser.findInArgList(strategy_pred, 'rule')
            try:
                operand_obj = pred_parser.findInArgList(heur_obj, 'operands')
            except AttributeError:
                print 'error with operands of:', pred_obj
                sys.exit()
            operand_list = pred_parser.argsToListOfStrings(operand_obj)
            self.strategy_data[strategy_name].append([strategy_desc, operand_list])
        else:
            # predicate indicates what we cannot do for the given time step
            self.strategy_data[strategy_name].append([strategy_desc + ' ' + strategy_name, []])

    def addParsedPredicate(self, pred_obj):
        if pred_obj.name == 'selectedHeurOperands':
            # get time object and operands as strings, then add to relevant time step
            operand_pred_obj            = pred_parser.findInArgList(pred_obj, 'operands')
            self.misc_data['operands']  = pred_parser.argsToListOfStrings(operand_pred_obj)
        elif pred_obj.name == 'holds':
            self.addHoldsPredicate(pred_obj)
        elif pred_obj.name == 'selectedHeuristic' and len(pred_obj.args) == 2:
            # NOTE: two versions of selectedHeuristic, we want the one with arity = 2
            time, action = pred_parser.argsToListOfStrings(pred_obj)
            self.misc_data['action']    = action
            self.misc_data['time']      = time
        elif pred_obj.name in factor_predicates:
            time, degree, coeff = pred_parser.argsToListOfStrings(pred_obj)
            factor_data_key = factor_name_dict[pred_obj.name]
            monomial_factor = EquationStepParser.makeMonomialFromData(degree, coeff)
            self.misc_data['factor_data'][factor_data_key] = monomial_factor
        elif pred_obj.name == 'strategyExplanation':
            self.addStrategyPredicate(pred_obj)
        elif pred_obj.name == 'optimalHeuristicInstance':
            #print 'fancy fancy', pred_obj
            heur_inst = pred_parser.findInArgList(pred_obj, 'rule')
            self.optimal_action = heur_inst.args[0].name
            self.optimal_operands = pred_parser.argsToListOfStrings(heur_inst.args[1])

    def makeAlmostFireExplanations(self, model_mgr):
        # check almost-fire status for any strategy that doesn't have any explanation data
        for strat in all_strategies:
            if strat not in self.strategy_data.keys():
                self.makeAlmostFireExplanationFor(strat, model_mgr)
    def makeAlmostFireExplanationFor(self, strategy, model_mgr):
        # do a key for heur name lookup need a key/
        # for each heuristic in the strategy class see if it almost fires
        for heur in explain.strategy_to_heuristic[strategy]:
            pred_key    = explain.getTemplateManager().lookupHeuristicKey(heur)
            almost_fire = explain.makeAlmostFireExplanations(pred_key, model_mgr)
            # add almost_fires explanation
            self.strategy_data[strategy] += almost_fire
            if almost_fire != [] :
                print 'this heuristic almost fired: ', heur



    # handles all post-processing after step parser
    # has received all predicates for this step
    def postProcessStepData(self, model_mgr):
        self.makeAlmostFireExplanations(model_mgr)
        self.translateStrategyData()
        self.makeExplanation(model_mgr)
        # TODO: translate almost fire stuff

        # XXX: hacky bug fix get rid of duplicates in strategy data explanations
        for key in self.strategy_data.keys():
            expl = [ (s, tuple(op)) for s, op in self.strategy_data[key] ]
            tup_expl = list(set(expl))
            temp =  [ [s, list(op)] for s, op in tup_expl]

            # reverse sorting ensures 'we will' explanation ends up after 
            # 'yes we can' explanations
            self.strategy_data[key] = sorted(temp, reverse=True)

    def getEqnString(self, as_latex=False, json_output=False):
        left    = self.makeEqnString('id(1,1)')
        right   = self.makeEqnString('id(1,2)')
        # NOTE: slicing to avoid outermost parens
        if left[0] == '(':
            left = left[1:-1]
        if right[0] == '(':
            right = right[1:-1]
        string = left + '=' + right
        return str(string)

    def translateStrategyData(self): 
        trans = translator.getTranslationsForNodeData(self.node_data)
        for strategy, explanation in self.strategy_data.items():
            # NOTE: sort so that when multiple terms can be operated on, the selected
            # terms are last
            new_sentences = self.translateSingleExplanation(explanation, trans) 
            new_sentences.sort(reverse=True)
            self.strategy_data[strategy] = new_sentences

        # XXX:
        # NOTE: remove this is a hacky solution to dealing with explanations for
        # suboptimal problems
        translated_optimal = [] 
        for node in self.optimal_operands:
            if node in trans.keys():
                translated_optimal.append(trans[node])
            else:
                translated_optimal.append(node)
        self.optimal_operands = translated_optimal

    def makeExplanation(self, model_mgr):
        if self.misc_data['action'] == '': # final step has no explanation
            return

        all_operands    = [self.misc_data['time']] + list(self.misc_data['operands'])
        condition       = self.misc_data['action']
        arity           = len(all_operands)
        template_key    = (condition, arity)

        # get manager and sentence templates
        template_mgr    = explain.getTemplateManager()
        template        = template_mgr.lookupTemplateFor(template_key)
        sentence_temp   = template.makeExplanation(all_operands, model_mgr, 1, self.misc_data['factor_data'])

        # NOTE: we have to translate the node ids used by the explanation sentences
        # Nell's code uses a binary tree representation, my ASP representation 
        # allows for trees with 3 or more children
        explanation    = [ temp.getSentenceFragments() for temp in sentence_temp]

        # translate explanations and operands
        # TODO: translation of operands should happen elsewhere?? !!!!
        translation_dict = translator.getTranslationsForNodeData(self.node_data)
        self.misc_data['explanation'] = self.translateSingleExplanation(explanation, translation_dict)
        self.misc_data['operands'] = self.translateListOfStrings(self.misc_data['operands'], translation_dict)

    # translates a single explanation array to use binary nodes
    def translateSingleExplanation(self, explanation_sentences, translations):
        # a single sentence looks like ['string explanation', [list_of_node_id_strings]]
        # explanation_sentences contains several such entries
        translate_sentence = lambda sent_data: [sent_data[0], self.translateListOfStrings(sent_data[1], translations)]
        return map(translate_sentence, explanation_sentences)

    # translate a list of strings so nodes match a binary tree representation
    def translateListOfStrings(self, string_list, translations):
        transform_fnc = lambda st : translations[st] if st in translations.keys() else st
        return map(transform_fnc, string_list)

    def makeEqnString(self, root_node):
        node_type = self.node_data[root_node]['type']
        if node_type == 'mono':
            return  self.makeMonomial(root_node) 
        # root node is a fraction, ensure numer and denom are put together correctly
        if node_type == 'div':
            numer = self.node_data[root_node]['numer']
            denom = self.node_data[root_node]['denom']
            oper_symbol = op_symbols[node_type]
            return '(' + self.makeEqnString(numer) + oper_symbol + self.makeEqnString(denom) + ')'
        else: # root_node is an add, neg or mul node
            child_strings = [self.makeEqnString(child) for child in self.node_data[root_node]['activechild']]
            # compose a string representation of every child first
            oper_symbol = op_symbols[node_type]
            
            # negation nodes have only one child
            if node_type == 'neg':
                return oper_symbol + '(' + oper_symbol + ')'
            else: 
                return '(' + oper_symbol.join(child_strings) + ')'

    @staticmethod
    def makeMonomialFromData(deg, coeff, var_str='x'):
        if coeff == '0' or deg == '0':
            return coeff
        elif deg == '1' and coeff == '1':
            return var_str
        elif deg == '1' and coeff == '-1':
            return '-'+var_str
        elif coeff == '1':
            return var_str + '^' + deg
        elif coeff == '-1':
            return '-'+var_str + '^' + deg
        elif deg == '1':
            return coeff + var_str
        else:
            return  coeff + var_str + '^' + deg

    def makeMonomial(self, node_name):
        """ Given a node name, construct the monomial referenced by that node"""
        deg     = self.node_data[node_name]['degree']
        coeff   = self.node_data[node_name]['coeff']
        return EquationStepParser.makeMonomialFromData(deg, coeff, self.var_str)

GeneratedSolution = namedtuple('GeneratedSolution', ['problem_string', 'solution_steps'])
class ProblemParser(object):
    def __init__(self, answer_set_predicates):
        super(ProblemParser, self).__init__()
        self.solution_steps = defaultdict(EquationStepParser)

        # data members used to store solutions and info about substitutions
        # this info is not saved in GeneratedSolution objects
        self.sub_data                   = {}
        self.soln_list                  = []

        # parse all the incoming predicates
        self.parseAnsSetFromPredicates(answer_set_predicates)

    # EquationStepParser contains lots of data we don't need after parsing
    # this method returns a GeneratedStep instance that has only what we want to save
    def toGeneratedSolution(self):
        sorted_steps = [ step for step_num, step in sorted(self.solution_steps.items()) ]
        generated_steps = [ step.toGeneratedStep() for step in sorted_steps]
        ## NOTE: should really happen in post-processing, move if this function gets too large
        #x_soln = self.getXSolnIfSubstitutionOccurs()
        #if x_soln != None:
            #generated_steps.append(x_soln)
        return GeneratedSolution(self.getProblem(), generated_steps)
    def addPredicateForTimeStep(self, time, pred_obj):
        self.solution_steps[time.step].addParsedPredicate(pred_obj)

    def parseAnsSetFromPredicates(self, predicates_list):
        """ compose as a string every solution in the predicate list given"""
        model_mgr = ModelManager()

        # parse predicates for each time step
        # TODO: add applicable and selected heuristics
        for predicate_string in predicates_list:
            pred_obj    = pred_parser.predicateStringToParsedPredicate(predicate_string)
            time        = pred_parser.getTimeFromPredObject(pred_obj)
            if time != None:
                self.addPredicateForTimeStep(time, pred_obj)
            # look for substitution data, to swap variables
            if pred_obj.name == 'substitutedDegree':
                _, degree = pred_parser.argsToListOfStrings(pred_obj)
                self.sub_data['degree'] = degree
                self.sub_data['step'] = int(time.step)
            if pred_obj.name == 'solutionValue' :
                # rational numbers are represented as numer, denom ordered pairs
                _, numer, denom = pred_parser.argsToListOfStrings(pred_obj)
                soln_value      = numer if denom == '1' else numer +'/' + denom 
                self.soln_list.append(soln_value)


            # add predicate to model manager
            model_mgr.addPredicate(predicate_string)

        # handle post processing at solution level, and step level
        self.solutionLevelPostProcessing()
        for eqn_step in self.solution_steps.values():
            eqn_step.postProcessStepData(model_mgr)

    def solutionLevelPostProcessing(self):
        self.updateVariablesIfSubstitutionOccurs()

    # add soulutions for x if y-substitution is used
    def getXSolnIfSubstitutionOccurs(self):
        # TODO: discuss with Nell how best to handle this
        if self.sub_data == {}:
            return None
        # root prefixes used to express root order
        # TODO: move elsewhere
        root_prefixes = {'2': '2nd', '3':'3rd' }
        root_prefixes.update(dict([(l, l+'th') for l in list('456789')]))
        
        prefix = root_prefixes[self.sub_data['degree']] + ' root of '
        x_solutions = ', '.join([prefix + s for s in self.soln_list])
        x_soln_str ='x = ' + x_solutions
        return GeneratedStep(x_soln_str, {})

    # if y-substitution is used, update the variable used for each 
    # step after the substitution
    def updateVariablesIfSubstitutionOccurs(self):
        if self.sub_data != {}: # a substitution was performed
            sub_step = self.sub_data['step']
            to_change = filter(lambda k : int(k) > sub_step, self.solution_steps.keys())
            for step in to_change:
                self.solution_steps[step].updateVariable('y')

    # TODO: for debugging purposes only, remove later!!
    def getSolutionString(self, as_latex=False, json_output=False):
        soln_trace = '\n'.join([step_obj.getEqnString() for step, step_obj in self.solution_steps.items()])
        return soln_trace
        #return 'Kuvira runs the world!! :)'
    def getProblem(self):
        return self.solution_steps[0].getEqnString()

class AnswerSetJSONEncoder(json.JSONEncoder):
    def default(self, ans_set_mgr):
        ans_set_dict = {}
        for index, problem in enumerate(ans_set_mgr.answer_sets_dict.values()):
            ans_set_dict[index] = self.encodeSingleProblem(problem)
        return json.JSONEncoder().encode(ans_set_dict) 

    # a problem is (possibly) composed of multiple solutions
    # TODO: can we remove some of the nesting????
    def encodeSingleProblem(self, problem):
        return [self.encodeSingleSolution(soln) for soln in problem] # encode all steps
    def encodeSingleSolution(self, solution):
        # a solution object saves a solution in a sequence of step objects
        step_list = [ [step_obj.equation_string, step_obj.step_data] for step_obj in solution.solution_steps]
        return step_list

class AnswerSetManager:
    """This class parses answer sets from stdin or json file, outputs to file in json format or user-friendly format"""
    def __init__(self, cmdline_args):
        self.cmdline_args = cmdline_args
        # answer set dict: problem_string --> list_of_solutions (list of GeneratedProblem instances)
        self.answer_sets_dict = defaultdict(list)

    def initFromSTDIN(self):
        """load answer sets from stdin NOTE: expects JSON input via clingo --outf=2"""
        all_answer_sets = self.__getJSONAnswerSetsFromSTDIN()
        # parse the answer sets
        for answer_set in all_answer_sets:
            predicates = answer_set['Value']
            # save generated version only
            generated_soln = ProblemParser(predicates).toGeneratedSolution()
            # add solution to list of solutions for its problem
            self.answer_sets_dict[generated_soln.problem_string].append(generated_soln)

    def __getJSONAnswerSetsFromSTDIN(self):
        """ read json from stdin, remove underscores, load via json module and return answer sets """
        clingo_output   = ''.join(sys.stdin.xreadlines())
        decoded_output  = json.loads(clingo_output.replace('_', ''))
        return decoded_output['Call'][0]['Witnesses'] # clingo provides lots of info, we just want answer sets

    def printAnswerSets(self, json_printing=False, with_explanation=False):
        """display all answer sets in user-friendly way"""
        for problem in self.answer_sets_dict.values():
            for generated_solution in problem:
                self.printSingleAnswerSet(generated_solution)
                print '$'*40
    def printSingleAnswerSet(self, generated_prob):
        for step in generated_prob.solution_steps:
            print step.equation_string + '\n\n'
            print step.step_data

#  TODO: shrink the size of this code later!!
def main(cmd_line_args):
    """ get cmd line args, initialize manager, set stdout if needed """
    # get cmd line args as dictionary
    cmd_line_args = vars(cmd_line_args)

    # create ans set manager and load with answer sets
    manager = AnswerSetManager(cmd_line_args)
    if cmd_line_args['json_input']:
        manager.initFromJSONFile(cmd_line_args['json_input'])
    else:
        manager.initFromSTDIN()

    # set stdout accordingly
    old_stdout = sys.stdout
    if cmd_line_args['save_file']:
        sys.stdout = open(cmd_line_args['save_file'], 'w')

    # print results. NOTE: prints to file if save_file parameter is used
    json_output = cmd_line_args['json_output'] == 'true'
    if json_output:
        #print AnswerSetJSONEncoder().encode(manager)
        print json.JSONEncoder().encode(manager.answer_sets_dict) 
    else:
        manager.printAnswerSets(json_printing=json_output, with_explanation=True)

    # restore stdout
    sys.stdout = old_stdout

def getCmdLineArgs():
    cmd_parser = argparse.ArgumentParser(description='Visualizer for ASP code')
    cmd_parser.add_argument('--json_output', default=False, required=False)
    cmd_parser.add_argument('--save_file', default=False, required=False) # provides file name for saving result
    cmd_parser.add_argument('--json_input', default=False, required=False)
    return cmd_parser.parse_args()

if __name__ == "__main__":
    main(getCmdLineArgs())


# TODO: 
# test translation code on more important examples
# ensure (x+2)/(x+2) --> 1
# XX finalize generation of problems with multiple solutions
# XX change answer_set manager to store problems based on initial generated problem, and to save solutions later
# write script to merge all json files into one thingy (if necessary)
# test multiple solns on a problem with more steps
# XX handle factor_data
# not producing all solutions!!

##### wish list
# change explanation storage to use namedtuple to conveniently access the explanations
#   convert to other format when printing or using json output
