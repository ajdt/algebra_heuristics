#!/usr/bin/env python
#
# Author:   Armando Diaz Tolentino <ajdt@cs.washington.edu> 
#
# Desc:     Provides helper functions to translate the node id's 
#           of expression trees generated by eqn_generator.lp into 
#           a binary tree format.
#

# return a dictionary with mappings (old_mapping --> new_mapping)
def getTranslationsForNodeData(node_data):
    # form AlgebraNode representations for each side of equation
    left_side = dictToAlgebraNodeRepr(node_data, 'id(1,1)')
    right_side = dictToAlgebraNodeRepr(node_data, 'id(1,2)')

    # convert each side to a binary tree
    left_side.convertTopLevelTreeToBinary()
    right_side.convertTopLevelTreeToBinary()
    
    # obtain the mappings
    translation_mappings = left_side.oldTagsAndNewTags()
    translation_mappings.update(right_side.oldTagsAndNewTags())
    return translation_mappings

# given a node_dictionary containing node_data
# produce an AlgebraNode() tree representation of the expression tree
def dictToAlgebraNodeRepr(node_dict, node_id):
    children = []
    # recursively create AlgebraNode instances for children
    if 'activechild' in node_dict[node_id].keys():
        child_list  = node_dict[node_id]['activechild']
        children    = [ dictToAlgebraNodeRepr(node_dict, child) for child in child_list]
    return AlgebraNode(node_id, children)


    
class AlgebraNode:
    """encodes an algebra expression tree: used to convert node ids to binary tree format"""
    def __init__(self, node_name, children):
        self.node_name, self.children = node_name, children
    def convertTopLevelTreeToBinary(self):
        self.toBinaryTree()
        if self.node_name == 'id(1,1)':
            self.tagBinaryTree(1, 1)
        else:
            self.tagBinaryTree(1,2) # XXX: assumes this is being called at toplevel!! 
    def toBinaryTree(self):
        # change tree to a binary tree inplace 
        while len(self.children) > 2:
            self.compressBottomTwoChildren()
        for child in self.children:
            child.toBinaryTree()
    def compressBottomTwoChildren(self):
        if len(self.children) <= 2 :
            return
        fst = self.children[0]
        snd = self.children[1]
        self.children = [AlgebraNode(None, [fst, snd])] + self.children[2:]

    # NOTE: for debugging only
    def toString(self, depth=0):
        root_str = '\t'*depth + str(self.node_name)
        for child in self.children:
            root_str += '\n' + child.toString(depth+1)
        return root_str

    def __str__(self):
        return self.toString()

    def tagBinaryTree(self, current_depth, node_num):
        self.new_id = 'id(' + str(current_depth) + ',' + str(node_num) + ')'
        if self.children == []:
            return
        self.children[0].tagBinaryTree(current_depth+1, node_num*2 -1 )
        if len(self.children) < 2:
            return
        self.children[1].tagBinaryTree(current_depth+1, node_num*2)
    def oldTagsAndNewTags(self):
        tags = {self.node_name : self.new_id}
        for child in self.children:
            tags.update(child.oldTagsAndNewTags())
        return tags
