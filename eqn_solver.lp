% Armando Diaz Tolentino <ajdt@cs.washington.edu> 
% 
% This file encodes a solver for the equations
% generated by eqn_generator.lp. It contains a
% definition of time that can easily be extended, and
% successor state axioms. Much terminology is borrowed from
% the situational calculus.
%
% XXX: this file depends on rule.lp for the rules used to solve an equation!

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Definition of Time %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% NOTE: Some of the terms used here borrow from situation calculus. However,
% I use a notion of 'time' instead of a situation because I don't consider
% the history of previously applied actions to define the current time state
% Time is defined by a step and a stream number (multiple time streams can be used)
_timeStep(0..maxSteps).
_timeStream(1..maxNumStreams).

_time(Step, Stream)					
		:-	_timeStep(Step),
			_timeStream(Stream).

_streamOf(_time(Step, Stream), Stream)					
		:-	_timeStep(Step),
			_timeStream(Stream).
_stepOf(_time(Step, Stream), Step)					
		:-	_timeStep(Step),
			_timeStream(Stream).

_nextTimeTick(FstTime, SndTime)					
		:-	_stepOf(FstTime, Step),
			_stepOf(SndTime, Step+1),
			_streamOf(FstTime, Stream),
			_streamOf(SndTime, Stream).
_startTime(Time)
		:-	_stepOf(Time, 0).
_stopTime(Time)
		:-	_stepOf(Time, maxSteps).
% every time(..) predicate is a valid time
_validTime(Time)
		:-	_stepOf(Time, Step).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fluents Over Time %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
_holds(Time, Fluent)
		:-	_holds(initially, Fluent),
			_startTime(Time).

_holds(NextTick, Fluent)			
		:-	_holds(Time, Fluent),
			_nextTimeTick(Time, NextTick),
			not _remove(Time, Fluent).

_holds(NextTick, Fluent)			
		:-	_introduce(Time, Fluent),
			_nextTimeTick(Time, NextTick).

% NOTE: facts about tempNodes should not hold across time steps
%	This is done b/c facts about tempNodes are also wrapped in _holds(..) predicate
_remove(Time, _fact(TempNode, Fact))
		:-	_holds(Time, _fact(TempNode, Fact)),
			_tempNode(TempNode).

% introduce/4 used to add fluents independent of representation
_introduce(Time, _fact(Node, _nodeField(Field, Value)))
		:-	_introduce(Time, Node, Field, Value).

					% updating fluents

% XX: for fields with multiple values, must use
%	introduce/remove directly. Otherwise, update will
%	remove all other values as well. 
_remove(Time, Fluent)			
		:-	_update(Time, Node, Field, NewValue),
			_holds(Time, _fact(Node, _nodeField(Field, OldValue))),
			Fluent = _fact(Node, _nodeField(Field, OldValue)).
_introduce(Time, Node, Field, NewValue)			
		:-	_update(Time, Node, Field, NewValue).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Selecting Rules %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% for each time step we can perform at most one applicable action
0 { _doAction(Time, Action)	:	_applicable(Time, Action) } 1
		:-	_time(Step, Stream),
			Time = _time(Step, Stream),
			not _stopTime(Time).

% action name performed at particular step
_actionForTimeStep(Time, ActionName)
		:-	_doAction(Time, _action(ActionName, Data)).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% solvability constraints %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% NOTE: all solvability constraints have x-term on leftSide
% 		This is to avoid redundancy of producing results like x=4 and 4=x as two different answer sets

%%:-	not _solved(Time), _stopTime(Time).%%

_solved(Time)	% solved if x = constant
	:-	_isXTerm(Time, leftSide),
		_isConstant(Time, rightSide).

%%[>_solved(Time)	% solved if c = c<]%%
	%%[>:-	_polyProperty(Time, leftSide, is_const),<]%%
		%%[>_polyProperty(Time, rightSide, is_const),<]%%
		%%[>_equal(Time, leftSide, rightSide).<]%%
%%_solved(Time)	% solved if (x+c_1) * (x + c_2) ... = 0 %%
	%%:-	_isProductOfLinearBinomials(Time, leftSide),%%
		%%_polyProperty(Time, rightSide, is_const),%%
		%%_polyProperty(Time, rightSide, is_zero).%%
%%_solved(SndTime)%%
	%%:-	_solved(FstTime),%%
		%%_nextTimeTick(FstTime, SndTime),%%
		%%not _stepHasAction(FstTime).%%

%%% NOTE: defining product of linear binomials only for leftSide b/c%%
%%% it won't be used elsewhere%%
%%_isProductOfLinearBinomials(Time, leftSide)%%
	%%:-	_isMul(Time, leftSide),%%
		%%not _hasNonBinomialChild(Time, leftSide).%%

%%_hasNonBinomialChild(Time, leftSide)%%
	%%:-	_childOf(Time, leftSide, Child),%%
		%%not _polyProperty(Time, Child, is_std_binomial).%%

%%_polyProperty(Time, Poly, is_std_binomial)%%
	%%:-	_activePoly(Time, Poly),%%
		%%_polyProperty(Time, Poly, is_linear),%%
		%%_linearCoeff(Time, Poly, 1).%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 1-GRAM DEFINITION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%_actionForTimeStream(Stream, Action)%%
	%%:-	_actionForTimeStep(Time, Action),%%
		%%_streamOf(Time, Stream).%%

%%_actionOccursInOneTimeStream%%
	%%:- _action(Action), 1 { _actionForTimeStream(Stream, Action) : _timeStream(Stream) } 1.%%

%%:-	not _actionOccursInOneTimeStream.%%
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% AVOID REDUNDANT STEPS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%_stepHasAction(Time)%%
	%%:-	_actionForTimeStep(Time, Name).%%

%%_sameTimeStream(Fst, Snd)%%
	%%:-	_streamOf(Fst, Stream),%%
		%%_streamOf(Snd, Stream),%%
		%%Fst != Snd.%%

%%_unequal(Fst, Snd)%%
	%%:-	_stepHasAction(Fst),%%
		%%_stepHasAction(Snd),%%
		%%Fst != Snd,%%
		%%_sameTimeStream(Fst, Snd),%%
		%%_holds(Fst, Fluent),%%
		%%not _holds(Snd, Fluent).%%
%%_redundantStep(Fst)%%
	%%:-	_stepHasAction(Fst),%%
		%%_stepHasAction(Snd),%%
		%%Fst != Snd,%%
		%%_sameTimeStream(Fst, Snd),%%
		%%not _unequal(Fst, Snd).%%
%%% CONSTRAINT: we should not have any redundant steps%%
%%:- _redundantStep(Step).%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% NOPs %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% CONSTRAINT: all NOPs must occur at the end%%
%%:-	_nextTimeTick(FstTime, SndTime),%%
	%%not _stepHasAction(FstTime),%%
	%%_stepHasAction(SndTime).%%


%%% used for projection%%
%%usesAction(Time, Name)%%
	%%:-	_actionForTimeStep(Time, Name).%%
