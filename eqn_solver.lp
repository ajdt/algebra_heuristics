% Armando Diaz Tolentino <ajdt@cs.washington.edu> 
% 
% This file encodes a solver for the equations
% generated by eqn_generator.lp. It contains a
% definition of time that can easily be extended, and
% successor state axioms. Much terminology is borrowed from
% the situational calculus.
%
% XXX: this file depends on rule.lp for the rules used to solve an equation!

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Definition of Time %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% NOTE: Some of the terms used here borrow from situation calculus. However,
% I use a notion of 'time' instead of a situation because I don't consider
% the history of previously applied actions to define the current time state
% Time is defined by a step and a stream number (multiple time streams can be used)
_timeStep(0..maxSteps).
_timeStream(1..maxNumStreams).

_time(Step, Stream)					
		:-	_timeStep(Step),
			_timeStream(Stream).

_streamOf(_time(Step, Stream), Stream)					
		:-	_timeStep(Step),
			_timeStream(Stream).
_stepOf(_time(Step, Stream), Step)					
		:-	_timeStep(Step),
			_timeStream(Stream).

_nextTimeTick(FstTime, SndTime)					
		:-	_stepOf(FstTime, Step),
			_stepOf(SndTime, Step+1),
			_streamOf(FstTime, Stream),
			_streamOf(SndTime, Stream).
_startTime(Time)
		:-	_stepOf(Time, 0).
_stopTime(Time)
		:-	_stepOf(Time, maxSteps).
% every time(..) predicate is a valid time
__validTime(Time)
		:-	_stepOf(Time, Step).

_sameStep(FstTime, SndTime)	% FstTime < SndTime will hold
		:-	__validTime(FstTime),
			__validTime(SndTime),
			_streamOf(FstTime, FstStream),
			_streamOf(SndTime, SndStream),
			FstStream < SndStream,
			_stepOf(FstTime, Step),
			_stepOf(SndTime, Step).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fluents Over Time %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
_holds(NextTick, Fluent)			
		:-	_holds(Time, Fluent),
			_nextTimeTick(Time, NextTick),
			not _remove(Time, Fluent).

_holds(NextTick, Fluent)			
		:-	_introduce(Time, Fluent),
			_nextTimeTick(Time, NextTick).

% NOTE: facts about tempNodes should not hold across time steps
%	This is done b/c facts about tempNodes are also wrapped in _holds(..) predicate
_remove(Time, _fact(TempNode, Fact))
		:-	_holds(Time, _fact(TempNode, Fact)),
			_tempNode(TempNode).

% introduce/4 used to add fluents independent of representation
_introduce(Time, _fact(Node, _nodeField(Field, Value)))
		:-	_introduce(Time, Node, Field, Value).

					% updating fluents

% XX: for fields with multiple values, must use
%	introduce/remove directly. Otherwise, update will
%	remove all other values as well. 
_remove(Time, Fluent)			
		:-	_update(Time, Node, Field, NewValue),
			_holds(Time, _fact(Node, _nodeField(Field, OldValue))),
			Fluent = _fact(Node, _nodeField(Field, OldValue)).
_introduce(Time, Node, Field, NewValue)			
		:-	_update(Time, Node, Field, NewValue).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Selecting Rules %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% for each time step we can perform at most one applicable action
0 { _selectedHeuristic(Time, HeuristicName)	:	_applicableHeuristic(Time, HeuristicName),
												_heuristicPriority(HeuristicName, Priority),
												not _higherPriorityIsSelectable(Time, Priority)} 1
		:-	_time(Step, Stream),
			Time = _time(Step, Stream),
			not _previousHeuristicNotFinished(Time),
			not _stopTime(Time).

% predicates to ensure we always choose the highest priority first
_heuristicPriority(Name, Priority)
	:-	_heuristic(Name, Priority, Condition).

_applicablePriority(Time, Priority)
	:-	_applicableHeuristic(Time, Name),
		_heuristicPriority(Name, Priority).

_higherPriorityIsSelectable(Time, SndPriority)
	:-	_applicablePriority(Time, FstPriority),
		_applicablePriority(Time, SndPriority),
		FstPriority < SndPriority.

% action name performed at particular step
% TODO: this may become unnecessary
_ruleForTimeStep(Time, RuleName)
		:-	_performRule(Time, _rule(RuleName, Operands)).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% solvability constraints %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% NOTE: all solvability constraints have x-term on leftSide
% 		This is to avoid redundancy of producing results like x=4 and 4=x as two different answer sets

:-	not _solved(Time), _stopTime(Time), not _disableSolvability.
:-	_solved(Time), _startTime(Time).	% eqn shouldn't be solved initially

_solved(Time)	% solved if x = constant
	:-	_isXTerm(Time, leftSide),
		_isConstant(Time, rightSide).
_solved(Time)	% solved if x = rational constant
	:-	_isXTerm(Time, leftSide),
		_isProperRational(Time, rightSide).

_solved(Time)	% solved if (x+c_1) * (x + c_2) ... = 0 
	:-	_isProductOfLinearBinomials(Time, leftSide),
		_isZero(Time, rightSide).

%%[>_solved(Time)	% solved if c = c<]%%
	%%[>:-	_polyProperty(Time, leftSide, is_const),<]%%
		%%[>_polyProperty(Time, rightSide, is_const),<]%%
		%%[>_equal(Time, leftSide, rightSide).<]%%

_solved(SndTime)
	:-	_solved(FstTime),
		_nextTimeTick(FstTime, SndTime),
		not _stepHasRuleApplication(FstTime).

% NOTE: defining product of linear binomials only for leftSide b/c
% it won't be used elsewhere
_isProductOfLinearBinomials(Time, leftSide)
	:-	_isMul(Time, leftSide),
		not _hasNonBinomialChild(Time, leftSide).

_hasNonBinomialChild(Time, leftSide)
	:-	_isATermOf(Time, leftSide, Child),
		not _isStdBinomial(Time, Child).

% NOTE: x + 4x, will count as std binomial, it shouldn't count
_isStdBinomial(Time, Poly)	
	:-	_isPolynomial(Time, Poly), 
		_hasXTerm(Time, Poly),
		_isLinear(Time, Poly).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 1-GRAM DEFINITION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

_ruleForTimeStream(Stream, Rule)
	:-	_ruleForTimeStep(Time, Rule),
		_streamOf(Time, Stream).
_diffTimeStreams(Fst, Snd)
	:-	_timeStream(Fst),
		_timeStream(Snd),
		Fst != Snd,
		_ruleForTimeStream(Fst, Rule),
		not _ruleForTimeStream(Snd, Rule).

%%% CONSTRAINT: first time stream does not equal second
:-	_timeStream(Fst),
	_timeStream(Snd),
	Fst != Snd,
	not _diffTimeStreams(Fst, Snd).


%%_ruleOccursInOneTimeStream%%
	%%:- _rule(Rule), 1 { _ruleForTimeStream(Stream, Rule) : _timeStream(Stream) } 1.%%

%%:-	not _ruleOccursInOneTimeStream.%%
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% AVOID REDUNDANT STEPS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
_stepHasRuleApplication(Time)
	:-	_ruleForTimeStep(Time, Name).

_sameTimeStream(Fst, Snd)
	:-	_streamOf(Fst, Stream),
		_streamOf(Snd, Stream),
		Fst != Snd.

_unequalTimeSteps(Fst, Snd)
	:-	__validTime(Fst),
		__validTime(Snd),
		Fst != Snd,
		_sameTimeStream(Fst, Snd),
		_holds(Fst, Fluent),
		not _holds(Snd, Fluent).
_redundantStep(Fst)
	:-	__validTime(Fst),
		__validTime(Snd),
		Fst != Snd,
		_sameTimeStream(Fst, Snd),
		not _unequalTimeSteps(Fst, Snd).
%%% CONSTRAINT: we should not have any redundant steps%%
:- _redundantStep(Step).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% NOPs %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% CONSTRAINT: all NOPs must occur at the end%%
:-	_nextTimeTick(FstTime, SndTime),
	not _stepHasRuleApplication(FstTime),
	_stepHasRuleApplication(SndTime).


% used for projection
%%usesRule(Time, Name)%%
	%%:-	_ruleForTimeStep(Time, Name).%%

%%% useful for 1-grams%%
%%% TODO: reuse old n-grams code instead??%%
selectedHeuristic(Name)
    :-	_selectedHeuristic(Time, Name).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Ensure Each Step Has Rule Application %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
_stepUsesHeuristic(Time)
	:-	_selectedHeuristic(Time, Name).
%%% CONSTRAINT: step without heuristic
:-	__validTime(Time),
	not _stopTime(Time),
	not _stepUsesHeuristic(Time).
